\section{Constructing Template Queries}

\begin{itemize}

\item Describe the template queries are compose of two type of clauses
\item Describe the motivation for the use of attribute clauses
\item Describe the problem with clauses with multiple predicates (to specific then recall is penalized)
\item Describe the algorithm to find key predicates
\item Describe how we sample the source and target data to find the key predicates
\item Describe heuristic for sampling. 
\item Describe how processing highly discriminative instance first help to find better keys.
\item Describe how the assumption that the sources instance are belong to the same class can speed up the generation of attribute clauses.
\item Describe the algorithm to map comparable keys

\item Describe the motivation for use class clauses (because the ambiguity at class level)
\item Define what is a class clause. (a predicate/value pair that select positive and no negative examples.)
\item Describe that we have to assume that instances belong to a same class. 
\item Then we case use the class based disambiguation to generate examples and those examples are used to find class clauses.
\item Describe the algorithm to find those class clauses.

\end{itemize}

In this section we describe how we construct the template queries in our approach. Basically, we want to avoid queries composed by too many clauses, because they are too selective, and they end up missing some positive matches. Therefore, in this work, we investigate template queries that are composed at most of two clauses; namely, an attribute clause and a class clause. The attribute clause helps us to find candidates based on the assumption that positive matches share a similar token on a pair of highly discriminative predicates. The class clause help us to disambiguate candidates that share the same token but belong to different classes.  We only build template queries that contains an attribute clause or an attribute clause and an class clause. 

An attribute clause denoted by $A(p_t,o_s)$ is derived from the comparable predicate pair $(p_s, p_t)$ where the triple $(s_i, p_s, o_s)$ exists in $G_s$. To build attribute clauses, we use known algorithms to determine the best pair of comparable predicates. Highly discriminative pairs are desired. The discriminative property guaranties that the clause will select a few candidates, impacting in the overall precision. Among those predicates, the set that cover all the positive match are used in process. The coverage property avoids that we miss positive matches, impacting the overall recall. To find the source predicates, we apply this algorithm over a subset of the source instances, which is quite straightforward. To find the target predicates and align them with the source predicates to form pairs is much less obvious; specially because we need to query the target endpoint to collect the data. A reasonable approach to get relevant data is to use the values of the selected source predicates to query the target endpoint. Then, we apply the algorithm over those candidates to determine the target predicates. Afterwards, we map the source and target predicates that their values are similar above a specific threshold. Notice that we do not use any schema information in this process, because in the heterogeneous setting, the schemas may not align. The final set of predicate pairs that we found is then transformed in a set of template queries containing one clause (one for each predicate pair).

In this work, we assume that the source instances to be matched belong to the same class (e.g. country, people, drugs, etc.). This assumption help us to find the best comparable predicates in two ways. First, because instances that share the same class are less diverse in the number of predicates; consequently, it is easier to find the ones with the highest coverage and discriminability. Second, the target instances for those source instances will also belong to a limited set of target class. Therefore, as both source and target sample are less diverse, we can with much less effort produce attribute clauses with the highest coverage and the maximal selectivity.

Beside of that, we can only produce class clauses with we consider this assumption. An class clause denoted by $C(p_t,o_t)$ is derived from a triple $(s_j, p_t, o_t)$ that exists in $G_t$. To build class clauses, we use a set-cover based algorithm \cite{DBLP:conf/soda/CarrDKM00} to quickly retrieve the list of predicate/value pair that select all positive elements but avoid the negative ones. The positive and negative matches are obtained during the candidate selection process that we will detail further.

