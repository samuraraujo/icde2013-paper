
\section{Related Work}

Several \emph{instance matching techniques} have been proposed to address both the efficiency and effectiveness of instance matching over single domain settings. Below we discuss state-of-the-art approaches, focusing on those that target the heterogeneous settings.


\emph{Blocking techniques} \cite{hernandez_merge/purge_1995} aims to make entity de-duplication more efficient by reducing the number of unnecessary comparisons between records. Based on a feature that is distinctive and can be processed efficiently (also called Blocking Key Value, BKV), instances are partitioned into blocks such that potentially similar instances (i.e. candidate results to be further refined) are placed in the same blocks.   Examples of blocking techniques include the sorted neighbourhood approach and canopy clustering \cite{mccallum_efficient_2000}. However, these techniques are focus on the single dataset settings, where the schema are homogeneous and the choice of a BKV is less problematic. 

So far, only one unsupervised blocking technique has been explicitly designed to work in the heterogeneous Web setting, where to tackle the heterogeneity between schemas, schema attributes are ignored and the BKV is simply the set of all tokens that can be extracted from the instance data~\cite{papadakis_efficient_2011}. As it does not use attribute information in the BKV, we call it as schema-agnostic blocking. However, the limitation of this approach is known, it may yield too many candidates because it looses valuable attribute information, which would form more discriminative keys. 

\emph{Candidate selection} applies the same blocking principles to reduce the number of comparison on the task of instance matching. Analogue to blocks, similar instances are grouped together forming candidate sets; and blocking keys are called candidate selection schemes.  Differently from the single dataset setting, in the multiple datasets setting, the alignment between candidate scheme from different sources is required, so that we can use information from the source scheme to select candidates based on the target scheme. Song et.al \cite{DBLP:conf/semweb/SongH11} focused on this setting and uses the attribute information, and its values, in the candidate schemes. Selected predicates are those with discriminativity and coverage above a threshold. However, the mapping of the candidate schemes is manually defined in their approach. ObjectCoref\cite{DBLP:conf/www/HuCQ11} applied a self-learning algorithm to solve instance matching itself. Although most of their principles can be used to generate candidate selection schemes, a direct translation of their algorithm to this task demands much more investigation. Differently from those approaches, we focus on generating both the candidate schemes and their alignments, in a unsupervised fashion.

\emph{Matching techniques} are employed after candidate selection, or blocking, for disambiguating candidate matches, therefore, targeting the effectiveness of the match. Mainly, they are named \emph{learning-based approaches} that can be further distinguished in terms of training data and degree of supervision, respectively (i.e. supervised, semi-supervised, unsupervised \cite{bernstein_discovering_2009,Song:2011:AGD:2063016.2063058,Niu:2011:ZWC:2063076.2063091}). ObjectCoref\cite{hu_bootstrapping_2011} is a supervised approach that self-learns the discriminativeness of RDF properties. Then, matches are computed based on comparing values of a few discriminative properties. RIMON~\cite{juanzi_li_rimom:_2009} is an unsupervised approach that firstly applies schema-based type of candidate selection to produce a set of candidate resources and then, uses a document-based similarity metric (cosine similarity) for disambiguating candidate resources. Chaudhuri et.al~\cite{DBLP:conf/vldb/ChaudhuriCGK07} propose an supervised approach for learning the recording matching queries. Basically, it learns from a set of positive and negative matching, a matching scheme, including the similarity function and threshold. Then, these matching schemes can be used to select the correct matches from set of possible candidates. Following a similar idea, KnoFuss+GA~\cite{DBLP:conf/esws/NikolovdM12} propose a online-learning system that can derive a matching scheme between heterogeneous sources.They do so by learning a fitness function for a genetic algorithm, which derives a suitable decision rule for a given matching task. Zhish.links ~\cite{DBLP:conf/semweb/NiuRZW11} uses background knowledge to tune the matching scheme. Mainly, they manually define a string and geographic similarity measure to produce precise matches. As most of the approaches, they process the data locally, indexing it to speed up its access. Although, all those approaches proof to to be effective in the heterogeneous settings and some have target the efficiency part as well, none of them target instance matching over remote data endpoints, where efficiency is the main issue. The learning of matching scheme from the data over those remote endpoints are not straightforward. Differently from accessing the data off-line, in the remote scenario, the data have to be queried. The challenge is to efficiently integrate this process of querying those endpoints into the learning of the matching scheme, so that only the necessary and sufficient data to produce the correct matches are queried. 

SERIMI ~\cite{serimi} is the only unsupervised approach that tackles the problem of instance matching over remote endpoints. It learns the candidate selection scheme by querying the endpoints and applies two matchers to eliminate string level ambiguity (many instances with similar name on the same class) and class level ambiguity (many instances with the same name on different classes) on the candidate sets. However, it does not pay attention to executing efficiently the candidate selection scheme, only focusing on the effective part of the problem. 

Differently, we target the efficiency and effectiveness of candidate selection over heterogeneous and remote data endpoints. We propose an ensemble of two matchers used for refined the candidate matches, and we show it efficiently produces competitive effective matches to those elaborated matching techniques.

 